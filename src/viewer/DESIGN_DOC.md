# Rezolus Dashboard Requirements & Design Document

## 1. Project Overview

### Purpose
- **Dashboard Objective**: Create an interactive visualization tool for Rezolus parquet recordings that enables users to analyze system performance metrics across multiple dimensions.

- **Primary Users**: 
  * Systems engineers
  * Performance analysts
  * DevOps teams
  * SREs (Site Reliability Engineers)
  * Other technical users investigating performance bottlenecks

- **Core Functionality**:
  * Timeline-based visualization of all Rezolus metrics
  * Drill-down capabilities from high-level summaries to detailed telemetry
  * Time window selection for focused analysis
  * Support for all metric types (counters, gauges, histograms)
  * Ability to view per-cgroup telemetry

### Success Criteria
- **Functional Success**:
  * Users can load and visualize any valid Rezolus parquet recording
  * All metrics categories are properly represented (BlockIO, CPU, Network/TCP, System Calls, Scheduler, Memory, GPU, etc.)
  * Navigation between summary and detailed views takes no more than 2 clicks
  * Time-based zooming feels responsive
  * One or more cgroups can be selected and viewed

- **User Experience Success**:
  * First-time users can find relevant metrics within 2 minutes
  * Users report the interface as "intuitive" and "responsive" in feedback
  * Dashboard maintains responsiveness with recordings up to 6 hours of secondly data (~200MB compressed)
  * Support for recordings with higher frequency data (up to 10Hz) for shorter durations (1 hour?)
  * Stretch goal: Support for longer durations

- **Business Success**:
  * Increased adoption of Rezolus based on dashboard demonstrations
  * Positive feedback from potential customers during demos

### Additional Considerations
- **Integration Context**: This dashboard fills a gap in the Rezolus ecosystem by providing a viewer for parquet recordings that are already being captured by existing tools.

- **Technical Considerations**:
  * Handle counter resets and rollovers appropriately for monotonically increasing metrics
  * Properly process histogram data, including detecting resets vs. rollovers before calculating percentiles
  * Ensure efficient loading and processing of time-series data

- **User Scenarios**:
  * An SRE investigating a production slowdown wants to quickly identify which subsystem is causing the bottleneck
  * A performance engineer analyzing a performance regression needs to pinpoint exactly when system behavior changed and which metrics were affected
  * A systems administrator wants to understand resource utilization patterns throughout the day

- **Out of Scope** (reserved for future paid offering):
  * Cross-metric correlation analysis
  * Custom annotation capabilities
  * Comparison between multiple recordings
  * Export/reporting features

## 2. Data Architecture

### Data Sources

#### Parquet File Structure and Schema
The dashboard will consume parquet files generated by Rezolus with the following structure:

- **File Format**: Apache Parquet
- **Primary Columns**:
  * `timestamp`: UTC epoch time in nanoseconds
  * `duration`: Time taken to collect the snapshot (nanoseconds)
  * Metric columns: All other columns represent metrics

- **Column Metadata (Critical)**:
  * Each column contains key-value metadata including:
    * `metric`: The short name of the metric (required for identification)
    * Various labels (key-value pairs) such as `name`, `id`, `direction`, `op`, `state`, etc.
    * `unit`: Base unit of measurement (when specified)
  * **IMPORTANT**: The column names in the parquet file are human-readable but MUST NOT be used as metric identifiers. Only the combination of a metric name with all its labels is guaranteed to be unique.

- **Data Types**:
  * `UInt64`: Used for counters
  * `Int64`: Used for gauges
  * `[UInt64]`: Used for histograms
  * Histogram columns have additional metadata fields:
    * `grouping_power`: Defines histogram granularity
    * `max_value_power`: Defines histogram range
    * Histogram implementation follows the specification at https://docs.rs/histogram

- **Data Organization**:
  * Single parquet file (multi-file capabilities reserved for future paid product)

### Data Transformations
Data transformation will happen in the backend.

- **Pre-Processing Requirements**:
  * On-demand decimation for visualization when time ranges exceed display capabilities
  * Counter rate calculations between decimated points when applicable
  * Histogram processing: Subtracting consecutive histograms (accounting for rollover/reset) before calculating percentiles
  * Unit conversions based on `unit` metadata:
    * Network throughput: Convert from Bytes to bits/second (Kbps, Mbps, Gbps, Tbps)
    * Preserve nanosecond precision for all time-based metrics
    * Use generic "per second" units for counter rates when specific unit not provided

- **Decimation Strategy**:
  * For counters: Decimate first, then calculate rates between intervals (accounting for rollover/reset)
  * For gauges: Use average across observations for the roll-up interval
  * For histograms: Decimate, calculate differences between consecutive histograms (accounting for rollover/reset), then generate percentiles

### Data Loading and Visualization

AI assisted. Human reviewed. May need revision.

- **Loading Strategy**:
  * Initial attempt to pass all data directly to uPlot for visualization
  * Progressive loading for large datasets:
    * Start with coarser time resolution
    * Refine when user selects specific time regions or zooms in
  * Support for recordings of various durations:
    * Short high-frequency recordings (up to 10Hz for 1-2 hours)
    * Longer recordings at secondly intervals (up to 2 days)
    * Weekly recordings would require significant decimation (86,400+ data points per day)

- **Time Window Navigation**:
  * Efficient time window selection
  * Zoom capabilities with appropriate decimation
  * Maintain context when navigating between time ranges

### Metrics Definition

AI assisted. This reflects most of what we have in Rezolus today. This will be
up to Brian to define the charts.

- **BlockIO Metrics**:
  * Operation Latency: For each operation type (read, write, flush, discard)
  * Bytes: Data volume for each operation type
  * Operations: Count of operations by type
  * Size Distribution: Histogram of operation sizes by type

- **CPU Metrics**:
  * Cores: Number currently online
  * Frequency: Derived from cpu_aperf, cpu_mperf, cpu_tsc (available per-core and per-cgroup)
  * L3 Hit Rate: Derived from cpu_l3_miss and cpu_l3_access
  * IPC (Instructions Per Cycle): Derived from cpu_instructions and cpu_cycles (available per-core and per-cgroup)
  * TLB Flush Events: cpu_tlb_flush with "reason" label ("task_switch", "remote_shootdown", etc.), available per-cgroup
  * Usage: cpu_usage per core in nanoseconds for various states ("user", "system", "nice", etc.), available per-cgroup

- **SoftIRQ Metrics**:
  * Count: Per-core counts for various types (hi, timer, net_tx, net_rx, etc.)
  * Time: Duration spent in each softirq type per core (nanoseconds)

- **GPU Metrics**:
  * Memory: gpu_memory in "free" or "used" states (occupancy = free/(free + used))
  * Memory Utilization: gpu_memory_utilization (percent from 0-100)
  * PCIe Bandwidth: gpu_pcie_bandwidth (link speed in bytes/second)
  * PCIe Throughput: gpu_pcie_throughput (for both transmit/receive, link utilization = throughput/bandwidth)
  * Power: gpu_power_usage (mW currently used)
  * Energy: gpu_energy_usage (mJ running usage)
  * Temperature: gpu_temperature
  * Clock: gpu_clock (for compute, graphics, memory, video)
  * Utilization: gpu_utilization (percent from 0-100)

- **Memory Metrics**:
  * System Memory: memory_total, memory_free, memory_available, memory_buffers, memory_cached
  * NUMA Statistics: memory_numa_hit, memory_numa_miss, memory_numa_foreign, memory_numa_interleave, memory_numa_local, memory_numa_other

- **Network Metrics**:
  * Carrier: network_carrier_changes
  * Error Statistics: 
    * network_receive_errors_crc (receive CRC errors)
    * network_receive_dropped (receive dropped packets)
    * network_receive_errors_missed (receive missed packets)
    * network_transmit_dropped (transmit dropped packets)
  * Traffic:
    * network_packets (with direction label "receive" or "transmit")
    * network_bytes (with direction label "receive" or "transmit")

- **Scheduler Metrics**:
  * scheduler_runqueue_latency (histogram)
  * scheduler_running_time (histogram)
  * scheduler_off_cpu_time (histogram)
  * scheduler_context_switch (counter)

- **System Call Metrics**:
  * syscall_count (counter, by type, available system-wide and per-cgroup)
  * syscall_latency (histogram, system-wide)

- **TCP Metrics**:
  * tcp_connect_latency (histogram)
  * tcp_packet_latency (histogram)
  * tcp_jitter (histogram)
  * tcp_srtt (smoothed round-trip time, histogram)
  * tcp_retransmit (counter)
  * tcp_bytes (counter, with direction label "transmit" or "receive")
  * tcp_packets (counter, with direction label "transmit" or "receive")
  * tcp_size_distribution (histogram, with direction label "transmit" or "receive")

- **Rezolus Self-Monitoring Metrics**:
  * CPU Usage: rezolus_cpu_usage (with state label "user" or "system")
  * Memory: 
    * rezolus_memory_usage_resident_set_size (memory occupancy in bytes)
    * rezolus_memory_page_reclaims
    * rezolus_memory_page_faults
  * BlockIO: rezolus_blockio_operations (for both read and write)
  * Context Switching: rezolus_context_switch (for both voluntary and involuntary)

### Data Processing Rules

AI assisted. All processing in Rust code.

- **Counter Rate Calculation**:
  * Formula: `rate = (current_value - previous_value) / time_delta`
  * Reset Detection: If `current_value < previous_value`, check:
    * If the difference is >= 2^63, it's a reset (not a rollover)
    * Handle by using `rate = current_value / time_delta`

- **Histogram Processing**:
  * Calculate the delta between consecutive histogram arrays
  * Reset Detection: For any bucket, if the change is >= 2^63, it's a reset
  * Use the histogram parameters to map bucket indices to values
  * Calculate desired percentiles from the delta histogram

- **CPU Usage Normalization**:
  * Convert CPU nanosecond usage to percentage: `usage_percent = (usage_ns / time_delta_ns) * 100`
  * Capped at 100% per core

- **Decimation Strategy**:
  * For time ranges > 1 hour: Aggregate to 15-second intervals
  * For time ranges > 6 hours: Aggregate to 1-minute intervals
  * For time ranges > 1 day: Aggregate to 5-minute intervals
  * For time ranges > 1 week: Aggregate to 15-minute intervals

### Metric Grouping Strategy

AI assisted. Roughly correct.

- **Summary Dashboard**:
  * CPU utilization (system-wide average)
  * Memory usage and availability
  * Network throughput (RX/TX)
  * Disk IO throughput and operation rate
  * GPU utilization (if present)
  * Key latency metrics (runqueue, disk operations, network)

- **CPU & Scheduler View**:
  * Per-core utilization heatmap
  * System-wide CPU usage by state
  * Frequency distribution
  * IPC and L3 hit rate
  * Runqueue latency percentiles
  * Context switch rate

- **Memory View**:
  * Total, free, and available memory
  * Buffer and cache usage
  * NUMA statistics
  * Page fault rates

- **BlockIO View**:
  * Operation rates by type
  * Throughput by type
  * Latency percentiles by operation type
  * Size distributions

- **Network View**:
  * Throughput (RX/TX)
  * Packet rates
  * Error statistics
  * TCP metrics

- **GPU View** (if present):
  * Utilization
  * Memory usage and utilization
  * Temperature
  * Clock speeds
  * Power usage

- **System Call View**:
  * Call rates by type
  * Latency percentiles
  * Per-cgroup breakdown

- **Rezolus Self-monitoring View**:
  * Rezolus CPU and memory usage
  * BlockIO and context switch metrics

## 3. User Interface Design

### Dashboard Layout

AI assisted. Human reviewed. May need revision.

- **Main Layout Structure**:
  * Persistent header with recording metadata and global time controls
  * Left sidebar for navigation between metric categories
  * Main content area for visualization panels in a two-column format

- **Dashboard Organization**:
  * Home/Summary dashboard as the landing page
  * Dedicated views for each major subsystem:
    * CPU & Scheduler
    * Memory
    * BlockIO
    * Network
    * GPU (if present)
    * System Calls
    * Rezolus Self-monitoring

- **Panel Layout**:
  * Two-column layout for visualization panels
  * Left column typically shows summary/average metrics
  * Right column typically shows detailed/per-CPU heatmaps
  * Consistent panel header with title and info tooltip

### Time Navigation Controls

We need some way of being able to zoom in on a region of interest, and reset
the view.

- Considerations
  * Do we want to allow fixed size windows (5m, 15m, ...) and prev/next
    navigation? Unclear if users would want to explore data like that
  * Do we need to give a way of refining the range to make getting to the region
    of interest and backing out a little bit for context to be more precise?
  * Would select region to zoom / double-click to reset be too basic and cause
    frustration?

### Visualization Components

AI assisted. Human reviewed. May need revision.

- **Chart Types**:
  * Line charts for time series data (via uPlot)
  * Heatmaps for per-CPU metrics (via uPlot)
  * Scatter/density plots for percentile visualization

- **Chart Features**:
  * Synchronized time axis across all charts
  * Automatic Y-axis scaling with override possible in dashboard JSON on a
    per-chart basis
  * Toggle for log/linear scale
  * Hover tooltips showing exact values and timestamps
  * Click-and-drag zooming

### Interactivity
This requires further consideration. Our current SystemsLab report has a nice
model for interactivity, particularly the per-cgroup and heatmap interactions
seem good. Zooming is a new consideration that needs thought.

Searching might be useful in the Apple System Preferences way of doing this, eg
searching for TLB should highlight that both the CPU and cgroup sections have
TLB metrics

Leaving the AI generated requirements here for reference

- **Chart Interactions**:
  * Hover: Show tooltip with exact values:
    * For line charts: Time and all series values in descending order
    * For per-CPU heatmaps: Time, CPU ID, and the specific value
  * Click + Drag: Zoom to time selection
  * Double-click: Reset zoom

- **Filtering and Selection**:
  * Filter dropdown for metrics with multiple dimensions (e.g., per-cgroup)
  * Search functionality for finding specific metrics

- **cGroup Selection**:
  * cGroup picker component allowing multi-selection of cgroups
  * Selected cgroups appear as individual time series
  * Non-selected cgroups combined into an "other" category
  * Support for handling hundreds of potential cgroups
  * Search/filter functionality within the picker

### Responsive Design
Want to make full use of the browser area. 2 column view unless browser width is
too narrow, and then single column view is desired below that break point. The
key consideration is when does a chart become too narrow to be useful?

Leaving the AI generated requirements here for reference

- **Target Screen Sizes**:
  * Primary: Desktop monitors (1920x1080 and higher)
  * Secondary: Laptop screens (1366x768 and higher)
  * Not optimized for mobile/tablet, but should degrade gracefully

- **Responsive Behavior**:
  * Collapsible sidebar to maximize visualization space
  * Dynamic resizing of charts based on available space
  * Fixed two-column layout for visualization panels

### Visual Design Elements

- **Color Palette** (Dark Theme):
  * Background: #121212 (primary background)
  * Secondary Background: #1E1E1E (panels/cards)
  * Text: #E0E0E0 (primary text)
  * Secondary Text: #ABABAB
  * Accent: #4299E1 (blue)
  * Border: #2D2D2D

- **Chart Colors** (accessible dark theme palette):
  * Series 1: #4299E1 (blue)
  * Series 2: #9F7AEA (purple)
  * Series 3: #48BB78 (green)
  * Series 4: #F6AD55 (orange)
  * Series 5: #F56565 (red)
  * Grid lines: #333333
  * Axis text: #ABABAB

- **Heatmap**: Viridis palette (blue → teal → green → yellow)

## 4. Technical Architecture

### Implementation Architecture

- **Open Questions**:
  * Will the frontend need to make queries to the backend to get different time
    granularity?

- **Backend**:
  * Rust-based implementation (`rezolus view` command)
  * Parquet file parsing and data processing handled server-side
  * Generate JSON representation of dashboard layout
  * Data transformation (rates, decimation, percentiles) computed on backend

- **Frontend**:
  * Minimal JavaScript with no heavy frameworks required
  * uPlot for all chart visualizations
  * Simple, functional UI components
  * Minimal dependencies to ensure fast loading

### Component Approach

- **UI Components**:
  * Simple HTML/CSS buttons and controls
  * Lightweight dropdown selectors
  * Minimal custom styling focused on functionality
  * Simple modals for cGroup selection

- **Visualization Components**:
  * uPlot for all charts (line charts, heatmaps)
  * Canvas-based rendering for performance
  * Consistent time-axis synchronization
  * Simple tooltips for point interactions

### Data Flow

1. User runs `rezolus view` command with parquet file path
2. Rust backend parses parquet file and prepares data
3. Backend generates JSON with embedded data and uPlot config
4. Browser renders the dashboard
5. Interactions trigger Rust backend processing as needed?
6. ???

### Performance Optimizations

This is AI generated. We need to consider where we might hit performance issues.

- **Data Loading**:
  * Implement lazy loading of data chunks
  * Load only the data needed for current view
  * Use decimation appropriate to time window and screen resolution

- **Rendering Efficiency**:
  * Throttle real-time updates during interactions
  * Use requestAnimationFrame for smooth animations
  * Memoize expensive calculations

- **Memory Management**:
  * Implement data cleanup for inactive views
  * Monitor and limit memory usage

## 5. User Experience

### Navigation Patterns

Key considerations:
- Time Range selection
- Sidebar nav for each section: Overview, CPU, GPU, Network, ...
- Should we have any nav across the top to jump to groups within a section?

AI generated below this line.

- **Primary Navigation**:
  * Sidebar navigation for switching between metric categories

- **Time Navigation Flow**:
  1. Start with summary view of entire recording
  2. Select time window of interest using brush selection
  3. Drill down into specific metrics during the selected time window
  4. Easy way to return to previous views or reset selection

- **Metric Discovery Flow**:
  1. Browse by category in sidebar
  2. Use search to find specific metrics

### Loading and Error States

No idea here. AI generated below this line.

- **Initial Loading Experience**:
  * Clear loading indicator for file parsing (which happens on the backend)
  * Dynamic refresh as data loads in
  * Progressive reveal of UI as data becomes available
  * Display file metadata immediately

- **Empty States**:
  * Informative message when no metrics match filters
  * Placeholder visuals that indicate expected content

- **Error Handling**:
  * Clear error messages for file parsing issues
  * Graceful degradation for unsupported features
  * Recovery options when possible
  * Detailed error information for technical users

### Accessibility Considerations

No idea here. AI generated below this line.

- **Keyboard Accessibility**:
  * All interactions available via keyboard
  * Focus management for modal dialogs
  * Skip navigation links

- **Screen Reader Support**:
  * Proper ARIA attributes
  * Meaningful alt text for visualizations
  * Table summaries for data grids

- **Visual Accessibility**:
  * Viridis palette for heatmaps ensures colorblind-friendly visualization
  * Sufficient contrast ratios for all text
  * Multiple visual cues beyond just color
  * Ability to increase text size

## 6. Implementation Plan

### Phased Development Approach

Human reviewed. May need revision.

#### Phase 1: Core Functionality (MVP)
- **Features**:
  * Basic parquet file loading and parsing
  * Summary dashboard with key metrics
  * Time window selection
  * Essential visualizations (line charts, heatmaps)
  * Navigation between main metric categories

- **Technical Foundation**:
  * Rust backend setup
  * Data processing pipeline
  * uPlot integration
  * Basic UI components

#### Phase 2: Enhanced Visualization and Interaction
- **Features**:
  * Complete metric set visualization
  * Advanced filtering and selection
  * Improved time navigation

- **Technical Additions**:
  * Performance optimizations
  * Enhanced UI components

#### Phase 3: Polish and Performance
- **Features**:
  * Enhanced accessibility
  * Performance improvements for large files

- **Technical Refinements**:
  * Caching strategies
  * Rendering optimizations
  * Browser compatibility

### Testing Strategy

Lol.

## 7. Browser and Device Support

AI generated. Needs review.

### Supported Browsers

- **Modern Browsers**:
  * Chrome 80+
  * Firefox 72+
  * Safari 13+
  * Edge 80+

- **Operating Systems**:
  * Windows 10/11
  * macOS 10.15+
  * Linux (major distributions)

### Device Support

- **Primary Target**:
  * Desktop monitors (1920×1080 and higher)
  * Laptop screens (1366×768 and higher)

- **Not Optimized For**:
  * Tablets
  * Mobile devices

## 8. Performance Requirements

AI generated. Needs review.

### Loading Performance

- **Initial Load**:
  * Time to interactive: < 3 seconds for application shell
  * Complete data loading: Dependent on file size
  * Progressive loading indicators for files > 50MB

- **Interaction Performance**:
  * Chart zooming/panning: < 100ms response time
  * Time selection updating: < 200ms for all visible charts to update
  * Tooltip display: < 50ms on hover

### Data Handling

- **File Size Support**:
  * Target optimal performance for files up to 100MB compressed
  * Support files up to 500MB with potential performance degradation
  * Plan for potential weekly recordings (2GB+) with significant decimation

## 9. Wireframes

AI generated. Needs review.

### Dashboard Layout - Two Column Format

```
+----------------------------------+
| Header & Time Navigation Controls|
+-------+--------------------------|
|       |                          |
|       | Chart Group Title        |
| Nav   |--------------------------|
| Bar   | CPU Busy % (average) | CPU Busy % per-CPU heatmap |
|       |--------------------------|
|       | CPU User % (avg)     | CPU User % per-CPU heatmap |
|       |--------------------------|
|       | CPU TLB Flush        | CPU TLB Flush per-CPU      |
|       | (total/s)            | heatmap                    |
|       |--------------------------|
|       | Next Metric Group Title  |
|       |--------------------------|
|       | ... other metrics in two-column format ... |
+-------+--------------------------+
```

### CPU View Example (Dark Theme, Two-Column)

```
+----------------------------------+
| Header & Time Navigation Controls|
+-------+--------------------------|
|       | CPU & Scheduler Metrics  |
| Nav   |--------------------------|
| Bar   | CPU Busy % (average) | CPU Busy % per-CPU heatmap |
|       |--------------------------|
|       | CPU User % (avg)     | CPU User % per-CPU heatmap |
|       |--------------------------|
|       | CPU System % (avg)   | CPU System % per-CPU       |
|       |                      | heatmap                    |
|       |--------------------------|
|       | CPU Frequency (avg)  | CPU Frequency per-CPU      |
|       |                      | heatmap                    |
|       |--------------------------|
|       | Run Queue Latency    | Context Switch Rate        |
|       | (percentiles)        | (system-wide)              |
+-------+--------------------------+
```

### cGroup Selector

```
+-------------------------------+
| cGroup Selector               |
|-------------------------------|
| [ ] Search cgroups...         |
|-------------------------------|
| [x] cgroup1                   |
| [x] cgroup2                   |
| [ ] cgroup3                   |
| [ ] cgroup4                   |
|        ...                    |
| [ ] cgroupN                   |
|-------------------------------|
| [Select All] [Clear] [Invert] |
+-------------------------------+
```